use std
use regex

use "types.use"

pkg pg =
	const gendfa	: (rl : rules# -> dfa#)
;;

const gendfa = {rl
	var dfa

	dfa = std.zalloc()
	addstate(dfa)
	for t in rl.toks
		if t.isregex
			addretok(dfa, t)
		else
			addstrtok(dfa, t)
		;;
	;;

	dumpdfa(dfa)

	-> dfa
}

const addstrtok = {dfa, tok
	var st, next

	st = 0
	for b in tok.pat
		next = dfa.states[st][b]
		if next == -1
			next = addstate(dfa)
			dfa.states[st][b] = next
		;;
		st = next
	;;
	accept(dfa, st, tok.id)
}

const addretok = {dfa, re
	match regex.parse(re.pat)
	| `std.Ok ast:
		todfa(dfa, ast)
	| `std.Fail m:
		std.fatal(1, "bad regex /%s/: %s\n", re.pat, regex.failmsg(m))
	;;
}

const todfa = {dfa, ast
	std.put("dfa-ing\n")
}

const accept = {dfa, st, id
	var oldsz, sz

	oldsz = dfa.accept.len
	sz = (st + 1) castto(std.size)
	dfa.accept = std.slzgrow(dfa.accept, std.max(oldsz, sz))
	std.slfill(dfa.accept[oldsz:], -1)
	dfa.accept[st] = id
}

const addstate = {dfa -> int
	var i

	dfa.states = std.slzgrow(dfa.states, dfa.states.len + 1)
	for i = 0; i < 256; i++
		dfa.states[dfa.states.len - 1][i] = -1
	;;
	-> (dfa.states.len - 1) castto(int)
}

const dumpdfa = {dfa
	var i, j
	var st

	std.put(" states = [\n")
	for j = 0; j < dfa.states.len; j++
		std.put("\t%i: [ ", j)
		st = dfa.states[j]
		for i = 0; i < st.len; i++
			if st[i] != -1
				std.put("%i: %i ", i, st[i])
			;;
		;;
		std.put("]\n")
	;;
	std.put("]\n")

	std.put("accept = [ ")
	for i = 0; i < dfa.accept.len; i++
		if dfa.accept[i] != -1
			std.put("%i:id=%i, ", i, dfa.accept[i])
		;;
	;;
	std.put("]\n")
}
