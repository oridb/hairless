use std

use "types.use"

pkg pg =
	const parse	: (f : byte[:] -> rules#)
;;

type parser = struct
	/* parse input */
	data	: byte[:]
	rest	: byte[:]
	fname	: byte[:]
	line	: int
;;

const parse = {f
	var rl, p
	p = mkparser(f)
	rl = std.mk([.infile=f])
	while !iseof(p)
		toplev(p, rl)
	;;
	-> rl
}

$noret const failparse = {p : parser#, msg, args : ...
	var sb, str, ap

	ap = std.vastart(&args)
	sb = std.mksb()
	std.sbfmt(sb, "{}:{}: ", p.fname, p.line)
	std.sbfmtv(sb, msg, &ap)

	str = std.sbfin(sb)
	std.put("{}", str)
	std.slfree(str)
	std.exit(1)
}

const toplev = {p, rl
	skipspace(p)
	if matchc(p, '%')
		directive(p, rl)
	else
		rule(p, rl)
	;;
}

const directive = {p, rl
	var u

	match word(p)
	| `std.Some "start":
		checkunset(p, rl.start, "'start' already sepecified\n")
		rl.start = expect(p, word(p), "expected word after 'start'\n")
	| `std.Some "pkg":
		checkunset(p, rl.pkgname, "'pkg' already sepecified\n")
		rl.pkgname = expect(p, word(p), "expected word after 'pkg'\n")
	| `std.Some "use":
		u = expect(p, usename(p), "expected use name after 'pkg'\n")
		rl.uses = std.slpush(rl.uses, u)
	| `std.Some "myr":
		checkunset(p, rl.myr, "'pkg' already sepecified\n")
		rl.myr = expect(p, myrlit(p), "expected myrddin literal after 'myr'\n")
	| `std.Some "tok":
		token(p, rl, false)
	| `std.Some "skip":
		token(p, rl, true)
	| `std.Some d:
		failparse(p, "unknown directive {}\n", d)
	| `std.None:
		failparse(p, "expected word after '%'\n")
	;;
}

var tokid = 0

const token = {p, rl, skip
	var name, pat, tok : tok#
	var isregex

	name = expect(p, word(p), "expected token name after '%tok'\n")
	skipspace(p)
	if !matchc(p, '=')
		failparse(p, "expected '=' after token name\n")
	;;

	skipspace(p)
	match peekc(p)
	| '/':
		isregex = true
		pat = expect(p, quoted(p, '/'), "expected token regex\n")
	| '"':
		isregex = false
		pat = expect(p, quoted(p, '"'), "expected token regex\n")
	| c:
		failparse(p, "invalid token pattern starting with '{}'\n", c)
	;;
	tok = std.mk([
		.id = tokid++,
		.isregex = isregex,
		.name = name,
		.pat = pat,
		.skip = skip
	])
	rl.toks = std.slpush(rl.toks, tok)
}

const rule = {p, rl
	var r

	match word(p)
	| `std.None:
		/* nothing */
	| `std.Some name:
		skipspace(p)
		if !matchc(p, ':')
			failparse(p, "expected ':' after rule name\n")
		;;
		while true
			r = rulebody(p, name)
			addrule(p, rl, r, name)
			skipspace(p)
			if matchc(p, ';')
				break
			;;
			if !matchc(p, '|')
				failparse(p, "expected '|' or ';' after rule body\n")
			;;
		;;
	;;
}

var nextruleid = 0
const rulebody = {p, name -> rule#
	var terms
	var action

	terms = [][:]
	while true
		match word(p)
		| `std.Some w:	terms = std.slpush(terms, w)
		| `std.None:	break
		;;
	;;
	skipspace(p)
	if peekc(p) == '{'
		match myrlit(p)
		| `std.None:	failparse(p, "expected myrlit\n")
		| `std.Some lit:
			action = lit
		;;
	else
		action = ""
	;;
	-> std.mk([.id=nextruleid++, .name=name, .terms=terms, .action=action])
}

generic expect = {p, tok : std.option(@a), msg -> @a
	match tok
	| `std.Some w:	-> w
	| `std.None:	failparse(p, msg)
	;;
}

const usename = {p
	skipspace(p)
	if peekc(p) == '"'
		-> quoted(p, '"')
	else
		-> word(p)
	;;
}

const quoted = {p, quot
	var start
	var n

	n = 0
	skipspace(p)
	if !matchc(p, quot)
		-> `std.None
	;;
	start = p.rest
	while p.rest.len > 0
		match getc(p)
		| '\n':	break
		| '\\':	n += std.charlen(getc(p))
		| c:
			if c == quot
				goto foundquote
			else
				n += std.charlen(c)
			;;
		;;
	;;
	failparse(p, "missing closing quote in string")
:foundquote
	-> `std.Some std.sldup(start[:n])
}


const word = {p
	var c, n
	var start

	n = 0
	skipspace(p)
	start = p.rest
	while p.rest.len > 0
		c = peekc(p)
		if wordchar(c)
			getc(p)
			n += std.charlen(c)
		else
			break
		;;
	;;
	if n > 0
		-> `std.Some std.sldup(start[:n])
	else
		-> `std.None
	;;
}

const wordchar = {c
	-> std.isalnum(c) || c == '_' || c == '$'
}

const myrlit = {p
	var inquote, instr
	var depth
	var sb

	skipspace(p)
	if !matchc(p, '{')
		-> `std.None
	;;
	sb = std.mksb()
	depth = 1
	inquote = false
	instr = false
	while !iseof(p)
		match getc(p)
		| '\\':	std.sbputc(sb, getc(p))
		| '"':	instr = !instr
		| '\'':	inquote = !inquote
		| '{':
			if !inquote && !instr
				depth++
			;;
		| '}':
			if !inquote && !instr
				depth--
				if depth == 0
					goto foundmyr
				;;
			;;
		| c:
			std.sbputc(sb, c)
		;;
	;;
	failparse(p, "missing closing '}' in myrddin literal\n")
:foundmyr
	-> `std.Some std.sbfin(sb)
}

const skipspace = {p
	var c, r

	r = p.rest
	while r.len > 0
		c = peekc(p)
		match c
		| ' ':	getc(p)
		| '\t':	getc(p)
		| '\n':
			getc(p)
			p.line++
		| '/':
			if !matchc(p, '*')
				break
			;;
			while p.rest.len > 0 && peekc(p) != '*'
				getc(p)
			;;
		| _:
			break
		;;
	;;
}

const matchc = {p, c
	var chr, s

	if p.rest.len == 0
		-> false
	;;
	(chr, s) = std.striter(p.rest)
	if c == chr
		p.rest = s
		-> true
	else
		-> false
	;;
}

const peekc = {p
	-> std.decode(p.rest)
}

const getc = {p
	var c, s

	(c, s) = std.striter(p.rest)
	p.rest = s
	-> c
}

const iseof = {p
	-> p.rest.len == 0
}

const mkparser = {path
	var p

	p = std.zalloc()
	p.line = 1
	p.fname = std.sldup(path)
	match std.slurp(path)
	| `std.Ok d:	p.data = d
	| `std.Fail _:	std.fatal("could not open '{}'\n", path)
	;;
	p.rest = p.data
	-> p
}

const addrule = {p, rl, r, name
	rl.rules = std.slpush(rl.rules, r)
}

const checkunset = {p, s, msg
	if s.len > 0
		failparse(p, msg)
	;;
}
