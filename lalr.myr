use std

use "types.use"

pkg pg =
	const genlalrtab : (rl : rules# -> lalr#)
	const dumplalrtab : (rl : rules# -> void)
;;

/* types */
type itemset = struct
	items	: item[:]
	has	: std.bitset#
;;

type item = struct
	rule	: rule#
	dot	: int
;;

var states

const genlalrtab = {rl
	var i0 : itemset#
	var i
	/*
	var edges
	var changed
	*/

	i0 = std.mk([
		.items = std.sldup([[.rule = augmented(rl), .dot = 0]][:]),
		.has = std.mkbs()
	])
	states = std.slpush(states, i0)
	/*edges = [][:]*/

	dumplalrtab(rl)
	stclosure(rl, i0)
	stgoto(rl, i0)
	for i = 0; i < states.len; i++
		std.put("i{}\n", i)
		dumpitmset(rl, states[i])
	;;
	-> std.zalloc()
}

const stclosure = {rl, itms
	var sym
	var changed

	changed = true
	dumpitmset(rl, itms)
	std.put("------\n")
	while changed
		changed = false
		for itm in itms.items
			sym = itm.rule.rhs[itm.dot]
			for r in rl.rules
				if r.lhs != sym
					continue
				;;
				if std.bshas(itms.has, r.id)
					continue
				;;
				changed = true
				std.bsput(itms.has, r.id)
				itms.items = std.slpush(itms.items, [.rule = r, .dot = 0])
				break
			;;
		;;
	;;
}

const stgoto = {rl, itms
	var dot, sym
	var items
	var succ

	std.put("nsym: {}\n", rl.nsym)
	for sym = 0; sym < rl.nsym; sym++
		std.put("building successors with {}\n", symstr(rl, sym))
		items = [][:]
		for itm in itms.items
			if itm.dot + 1 == itm.rule.rhs.len
				continue
			;;
			dot = itm.rule.rhs[itm.dot + 1]
			if dot != sym
				continue
			;;
			items = std.slpush(items, [
				.rule = itm.rule,
				.dot=itm.dot + 1])
		;;
		if items.len > 0
			succ = std.mk([
				.items = items,
				.has = std.mkbs(),
			])
			stclosure(rl, succ)
			states = std.slpush(states, succ)
		;;
	;;
}

const augmented = {rl
	std.htput(rl.symname, rl.nsym, "$start")
	-> std.mk([
		.lhs = rl.nsym,
		.rhs = std.sldup([rl.start, TokEof][:]),
		.name = ".s0",
		.act = "ACCEPT"
	])
}

const dumpitmset = {rl, is
	for itm in is.items
		std.put("\t")
		dumpitm(rl, itm)
	;;
}

const dumpitm = {rl, itm
	var r, i

	r = itm.rule
	std.put("{}\t: ", symstr(rl, r.lhs))
	i = 0
	for t in r.rhs
		if i == itm.dot
			std.put("@") /* more noticable than a period */
		;;
		std.put("{} ", symstr(rl, t))
		i++
	;;
	std.put("{{{}}}\n", r.act)
}

const symstr = {rl, sym
	match std.htget(rl.symname, sym)
	| `std.Some str:	-> str
	| `std.None:	std.fatal("no sym {}\n", sym)
	;;
}

const dumplalrtab = {rl
	/*
	std.put("infile:\t{}\n", rl.infile)
	std.put("pkg:\t{}\n", rl.pkgname)
	std.put("start:\t{}\n", rl.start)
	std.put("use:\t")
	for u in rl.uses
		std.put("{} ", u)
	;;
	std.put("\n")
	std.put("myr:\t{{{}}}\n", rl.myr)
	for t in rl.toks
		std.put("tok {} : {}\n", t.name, t.pat)
	;;
	for r in rl.rules
		dumprule(r)
	;;
	*/
}

/*
const dumprule = {rl, r
	std.put("{}\t: ", symstr(rl, r.lhs))
	for t in r.rhs
		std.put("{} ", symstr(rl, t))
	;;
	std.put("{{{}}}\n", r.act)
}
*/

